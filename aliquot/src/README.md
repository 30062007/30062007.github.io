Στο πρόγραμμα aliquot.c που έφτιαξα αρχικά δήλωσα τις βιβλιοθήκες γλώσσας stdio.h (για printf,scanf κλπ) και math.h
(για την συνάρτηση sqrt()).Στην συνέχεια αρχικοποίησα εναν πίνακα seen[] και μια μεταβλητή seen_count για την ανίχνευση κύκλων στο πρόγραμμα.Με την συνάρτηση aliquot_sum() υπολόγισα τους ορθούς διαιρέτες του n (αρχικός ακέραιος αριθμός).Φρόντισα ο n να μην είναι αρνητικός και αρχικοποίbrησα το sum με 1 αφού το 1 είναι πάντα ορθός διαιρέτης οποιουδήποτε αριθμού, ενώ έφτιαξα επίσης και μια μεταβλητή sqrt_n που την αρχικοποίησα με την συνάρτηση sqrt() (η τετραγωνική ρίζα του αριθμού).'Υστερα με μια μεταβλητή divisor έλεγξα για όλους τους αριθμούς απο το 2 μέχρι την ρίζα αν είναι ορθοί διαιρέτες του n και με μια μεταβλητή sub βρήκα και τους συμπληροματικούς διαιρέτες (κερδίζοντας έτσι πολύ χρόνο) και τους πρόσθεσα στο sum (εφόσον divisor!=sub).Τελικά με την εντολή return sum πείρα όλους τους ορθούς διαιρέτες.Με την συνάρτηση has_seen() ελέγξα αν το n έχει ξαναεμφανιστεί στον πίνακα seen[] και κατα συνέπεια αν έχουμε λούπα.Ετσι με μια μεταβλητή i προσπέλασα τα στοιχέια του πίνακα και τα σύγκρινα με το n για να εντοπίσω πιθανό κύκλο.Επακολούθησε η χρήση της συνάρτησης add_seen() στην οποία πρόσθεσα τον αριθμό n στον πίνακα n και αύξησα το seen_count κατα 1 (προσέχοντας μην περάσω το επιθυμιτό όριο).Συνεπώς άνοιξα την main συνάρτηση.Το πρώτο πράγμα που έκανα ήταν να αρχικοποιήσω τις μεταβλητές n,maxl,tos,count τις οποίες με την χρήση μηνύματος ζήτησα απο τον χρήστη να μου τις δώσει μεριμνόντας παράλληλα να είναι έγκυρες(την count δεν ζήτησα να μου την δώσει την είχα αρχικοποιήση με 0).'Ελεγξα την περίπτωση της υπερχείλισης και φρόντισα να τυπώνεται ο πρώτος αριθμός n αν ο χρήστης επιλέξει για την μεταβλητή tos (type of sequence) την επιλογή f, καθώς και με την βοήθεια τις συνάρτησης add_seen() κράτησα ιστορικό για να προσέχω τις λούπες σε περίπτωση που το maxl είναι ίσο με το 0.Μετά με την εντολή επανάληψης while() ξεκίνησα έναν βρόγχο που επαναλαβανόταν μέχρι να φτάσει σε κάποιο όριο που έχει ορίσει ο χρήστης ή επί άπειρο (maxl=0).Ο υπολογισμός του επόμενου όρου έγινε με την βοήθεια της συνάρτησεις aliquot_sum() και φρόντισα αλλη μία φορά να μην υπάρχει υπερχείλιση.Επίσης με κάθε επανάληψη ο μετρητής count αυξανάνεται κατα 1 (κατι που είναι χρήσιμο στην περίπτωση tos=l).Έπειτα στην περίπτωση που το maxl=0 χρησιμοποίησα την συνάρτηση has_seen() για να εντοπίσω κύκλους στην ακολουθία και έτσα εκτύποσα τον αριθμό και το βήμα που παρατηρίθηκε η επανάληψη.Σε περίπτωση που παρατηριθεί λούπα σταματάει η επανάληψη (break;) αλλιώς συνεχίζει κανονικά και ενημερώνει την συνάρτηση  add_seen().Έτσι το n πέρνει την τιμή του νέου όρου και εκτυπώνεται (εφόσον tos=f).Τελικά αν το n=0 η επανάληψη σταματάει και εκτυπώνω την μέγιστη ακολουθία τις επανάληψης αν ο χρήστης επιλέξει την επιλογή 'l'.Το πρόγραμμα λοιπόν καταλήγει στην εντολή return 0 που συμβολίζει το λειτουργικό τέλος του προγράμματος.
